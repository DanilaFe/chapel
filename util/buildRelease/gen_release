#!/usr/bin/env python3
import os
import sys
import shutil
import subprocess
import tempfile
import glob
import itertools
from contextlib import contextmanager


@contextmanager
def cd(path):
    cwd = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(cwd)


def run(*args, **kwargs):
    print(f"+ {' '.join(args)}")
    result = subprocess.run(args, **kwargs)
    if result.returncode != 0:
        raise RuntimeError(
            f"[gen_release] Command failed with error code: {result.returncode}"
        )
    return result


def make(*args, **kwargs):
    return run("make", *args, **kwargs)


def pjoin(*args):
    return os.path.join(*args)


def rm_rf(*paths):
    for path in paths:
        for p in glob.glob(path):
            shutil.rmtree(p, ignore_errors=True)


# explicit files to include
files = [
    "ACKNOWLEDGEMENTS.md",
    "CHANGES.md",
    "CONTRIBUTORS.md",
    "COPYRIGHT",
    "LICENSE",
    "LICENSE.chapel",
    "Makefile",
    "CMakeLists.txt",
    "Dockerfile",
    "README.rst",
    "README.files",
    "compiler/codegen/reservedSymbolNames",
    "configure",
    "highlight/README.md",
    "util/README",
    "util/buildRelease/chpl-make-cpu_count",
    "util/buildRelease/install.sh",
    "util/chpl-completion.bash",
    "util/printchplenv",
    "util/setchplenv.bash",
    "util/setchplenv.csh",
    "util/setchplenv.fish",
    "util/setchplenv.sh",
    "util/start_test",
    "util/chpltags",
    "frontend/include/chpl/config/config.h.cmake",
]

# C/C++ sources
code_dirs = ["compiler", "frontend"]
# include these dirs and their entire contents
complete_dirs = [
    "compiler/etc",
    "doc",
    "examples",
    "highlight/emacs",
    "highlight/source-highlight",
    "highlight/vim",
    "make",
    "man/man1",
    "modules",
    "runtime",
    "third-party",
    "util/build_configs",
    "util/chplenv",
    "util/config",
    "util/cmake",
    "util/quickstart",
    "util/test",
    "tools/chpldoc",
    "tools/chplvis",
    "tools/c2chapel",
    "tools/mason",
    "tools/protoc-gen-chpl",
    "tools/unstableWarningAnonymizer/",
    "tools/chapel-py",
    "tools/chplcheck",
    "tools/chpl-language-server",
]


def main():
    version = ""
    if len(sys.argv) > 1:
        version = sys.argv[1]

    reldir = f"chapel-{version}" if version else "chapel"

    # Find CHPL_HOME. If unset, use root of repo relative to this script.
    chplhome = os.getenv(
        "CHPL_HOME",
        os.path.dirname(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        ),
    )

    # pointers to temporary directory where chapel will be built
    basetmpdir = os.getenv("CHPL_GEN_RELEASE_TMPDIR", tempfile.gettempdir())
    user = os.getlogin()
    tmpdir = tempfile.mkdtemp(
        prefix=f"chapel-release.{user}.deleteme.", dir=basetmpdir
    )
    archive_dir = pjoin(tmpdir, reldir)
    rootdir = pjoin(tmpdir, "chpl_home")

    rm_rf(tmpdir)
    os.makedirs(archive_dir, exist_ok=True)

    # TODO: can we use pythons builtin tar module instead of system commands?
    tar_executable = "gtar" if shutil.which("gtar") else "tar"

    # If CHPL_GEN_RELEASE_NO_CLONE is set in environment, do not clone the repo
    # Just use whatever is found in $CHPL_HOME
    if "CHPL_GEN_RELEASE_NO_CLONE" in os.environ:
        # copy the current CHPL_HOME into the directory where chapel will be built
        print(
            "[gen_release] CHPL_GEN_RELEASE_NO_CLONE: Creating build workspace with tar..."
        )
        with cd(chplhome):
            p = run(tar_executable, "-cf", "-", ".", stdout=subprocess.PIPE)
            with cd(archive_dir):
                run(tar_executable, "-xf", "-", input=p.stdout)
        resultdir = pjoin(chplhome, "tar")
    else:
        # check out a clean copy of the sources into the directory where chapel will be built
        git_url = os.getenv(
            "CHPL_HOME_REPOSITORY", "https://github.com/chapel-lang/chapel"
        )
        git_branch = os.getenv("CHPL_GEN_RELEASE_BRANCH", "main")
        repo_cache_path = os.getenv("REPO_CACHE_PATH", "/missing")
        git_commit = os.getenv("CHPL_GEN_RELEASE_COMMIT", None)

        print(
            f"[gen_release] Cloning the sources (repo: {git_url} branch: {git_branch})..."
        )
        cmd = (
            [
                "git",
                "clone",
                "--reference-if-able",
                f"{repo_cache_path}/chapel.git",
                "--branch",
                git_branch,
            ]
            + (["--depth", "1"] if git_commit is None else [])
            + [
                git_url,
                rootdir,
            ]
        )
        run(*cmd)

        if git_commit is not None:
            print(f"[gen_release] Checking out revision {git_commit}...")
            with cd(rootdir):
                run("git", "reset", "--hard", git_commit)

        with cd(rootdir):
            print("[gen_release] Confirm final Git source version used.")
            run("git", "--no-pager", "status")
            run("git", "--no-pager", "log", "-1")

            # write the git-sha while we have the .git directory
            run(
                "util/config/write-git-sha",
                "frontend/lib/util",
                "--build-version",
                f"--chpl-home={rootdir}",
            )
            # use git archive to copy all the files under source control into the archive directory.
            print("[gen_release] Creating build workspace with git archive...")

            p = run(
                "git", "archive", "--format=tar", "HEAD", stdout=subprocess.PIPE
            )
            with cd(archive_dir):
                run(tar_executable, "-xf", "-", input=p.stdout)

            # explicitly copy the BUILD_VERSION file and git-version.cpp files
            print("[gen_release] Copying BUILD_VERSION file.")
            shutil.copyfile(
                "compiler/main/BUILD_VERSION",
                pjoin(archive_dir, "compiler/main/BUILD_VERSION"),
            )
            print("[gen_release] Copying git-version.cpp")
            shutil.copyfile(
                "frontend/lib/util/git-version.cpp",
                pjoin(archive_dir, "frontend/lib/util/git-version.cpp"),
            )

        if "CHPL_HOME" in os.environ:
            resultdir = pjoin(os.getenv("CHPL_HOME"), "tar")
        else:
            resultdir = basetmpdir

    with cd(archive_dir):

        print("[gen_release] Creating the spec tests...")
        make("spectests")

        # Docs/man page must be built first so we can get rid of any extra files
        # (chpldoc) with a clobber
        print("[gen_release] Building the docs...")
        # Set CHPL_COMM to none to avoid issues with gasnet generated makefiles not
        # existing because we haven't built the third-party libs and set CHPL_LLVM to
        # none since we don't need it to build the docs
        os.environ["CHPL_HOME"] = str(archive_dir)
        os.environ["CHPL_COMM"] = "none"
        os.environ["CHPL_LLVM"] = "none"
        print(f"[gen_release] CHPL_HOME is set to: {os.environ['CHPL_HOME']}")

        if "CHPL_GEN_RELEASE_SKIP_DOCS" not in os.environ:
            print("[gen_release] Building the html docs...")
            make("chapel-py-venv")
            make("docs")

            print("[gen_release] Pruning the docs directory...")
            with cd("doc"):
                make("clean-symlinks")
                make("prunedocs")
                rm_rf(
                    "Makefile*",
                    "util",
                    "rst/conf.py",
                    "rst/index.rst",
                    "rst/*/index.rst",
                    "rst/developer",  # remove when dev-docs enabled
                    "rst/meta",
                )

            print("[gen_release] Building the man pages...")
            make("man")
            make("man-chpldoc")
        else:
            os.makedirs(pjoin("man", "man1"), exist_ok=True)

        make("clobber")

        print("[gen_release] Creating the examples directory...")
        os.unlink("examples")  # remove examples symbolic link
        shutil.copytree("test/release/examples", "examples")
        with cd("util"):
            shutil.copyfile("start_test", "../examples/start_test")

        # print "[gen_release] Removing Makefiles that are not intended for release...\n";

        # print "[gen_release] Removing compiler directories that are not intended for release...\n";

        print(
            "[gen_release] Removing runtime directories that are not ready for release..."
        )
        rm_rf(
            pjoin("runtime", "src", "launch", "dummy"),
            pjoin("runtime", "src", "launch", "mpirun"),
        )

        print(
            "[gen_release] Removing frontend test directory which is not intended for release..."
        )
        rm_rf(pjoin("frontend", "test"))

        print(
            "[gen_release] Removing third-party directories that are not intended for release..."
        )
        rm_rf(
            pjoin("third-party", "*.devel*"),
            pjoin("third-party", "chpl-venv", "*.devel*"),
            pjoin("third-party", "chpl-venv", "chplspell-requirements.txt"),
        )

        print(
            "[gen_release] Removing Git metadata files not intended for release..."
        )
        for p in itertools.chain(
            glob.glob(".gitignore", recursive=True),
            glob.glob(".gitattributes", recursive=True),
        ):
            os.unlink(p)

        # TODO: can we use python chmod instead of system commands?
        print("[gen_release] Chmodding the hierarchy")
        run("chmod", "-R", "ugo+rX", ".")
        run("chmod", "-R", "go-w", ".")

        tarfiles = []
        for file in files:
            if not os.path.exists(file):
                print(f"[gen_release] {file} does not exist")
                sys.exit(9)
            tarfiles.append(pjoin(reldir, file))

        for d in code_dirs:
            for fullpath in glob.glob(pjoin(d, "**"), recursive=True):
                suffix = os.path.splitext(fullpath)[1]
                name = os.path.basename(fullpath)
                if suffix in {".h", ".cpp", ".c", ".ypp", ".lex"} or any(
                    n in name
                    for n in {
                        "Makefile",
                        "README",
                        "BUILD_VERSION",
                        "CMakeLists.txt",
                    }
                ):
                    tarfiles.append(pjoin(reldir, fullpath))

        for d in complete_dirs:
            if not os.path.exists(d):
                print(f"[gen_release] {d} does not exist")
            tarfiles.append(pjoin(reldir, d))

        if not os.path.exists(resultdir):
            print(f"Creating {resultdir}")
            os.makedirs(resultdir, exist_ok=True)

        tarball_name = pjoin(resultdir, f"{reldir}.tar.gz")
        cmd = [
            tar_executable,
            "-cz",
            "-f",
            tarball_name,
            "--no-xattrs",
        ] + tarfiles
        os.chdir("..")
        print(f"[gen_release] {' '.join(cmd)}")
        run(*cmd)

    print(f"[gen_release] Left result in {tarball_name}")


if __name__ == "__main__":
    main()
