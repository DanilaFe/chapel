/*
 * Copyright 2020-2023 Hewlett Packard Enterprise Development LP
 * Copyright 2004-2019 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
Description:

This script analyzes the output generated by your program and provides a
comprehensive summary of different types of unstable warnings without
revealing any implementation details about the program.
It helps us understand the distribution of unstable warnings in your program,
enabling us to identify and prioritize the most common types of unstable
features.


COMPILE: chpl unstableAnonScript.chpl
USAGE: unstableAnonScript [-h, --help] [-c, --csv] [-i, --inputFiles <INPUTFILE> ...] [-o, --outputFile <OUTPUTFILE>]

OPTIONS:
  -h, --help                    Display this message and exit
  -c, --csv                     Write the output in csv format.
                                Defaults to false, which writes in a pretty format
  -i, --inputFiles <INPUTFILE>  The files containing the warnings. Defaults to stdin
  -o, --outputFile <OUTPUTFILE> The file to write the output to. Defaults to stdout

Example Usage:
./unstableAnonScript < warnings.txt > output.txt
./unstableAnonScript -i warnings.txt -o output.txt  # Equivalent to above
./unstableAnonScript -i sample.warnings sample.bad  # Can specify multiple inputFiles at once
./unstableAnonScript -i sample.warnings  --csv      # Can print in csv

*/

import IO;
import SortedMap.sortedMap as map;
import Regex.regex;
import ArgumentParser;

proc countUniqueWarnings(ref warningsMap: map(string, int), inputFileReader: IO.fileReader(?)){
  // A pattern of a typical warning line
  // Ex: filename.chpl:lineNumber: warning message blah
  const warningRegex = new regex(".*.chpl:\\d+: (.*)\n"); // The  (.*) is a capture group
  var warning : string;
  for (fullMatch, warningMatch) in inputFileReader.matches(warningRegex, captures=1) {
    inputFileReader.extractMatch(warningMatch, warning);
    // Check if the string mentions that something is unstable
    // If so, add it to the map
    if warning.find("unstable") == -1 then
      continue;
    if warningsMap.contains(warning) {
      warningsMap[warning] += 1;
    } else {
      warningsMap[warning] = 1;
    }
  }
}


inline proc prettyPrintMap(m : map(?), writer: IO.fileWriter(?)){
  for key in m.keys() {
    if m[key] < 2 then
      writer.writeln(m[key], " instance of \"", key, "\"");
    else writer.writeln(m[key], " instances of \"", key, "\"");
  }
}


inline proc csvPrintMap(m : map(?), writer: IO.fileWriter(?)){
  for key in m.keys() {
    writer.writeln("\"", key, "\"", ",", m[key]);
  }
}

proc main(args:[]string) throws {

  var parser = new ArgumentParser.argumentParser();
  var inputFilesArg = parser.addOption(name="inputFile", numArgs=1..,
                            opts = ["-i", "--inputFiles"],
                            help="The files containing the warnings. Defaults to stdin");
  var outputFileArg = parser.addOption(name="outputFile",
                            opts = ["-o", "--outputFile"],
                            help="The file to write the output to. Defaults to stdout");
  var csvArg = parser.addFlag(name="csv", defaultValue=false,
                            opts = ["-c", "--csv"],
                            help="Write the output in csv format. Defaults to false, which writes in a pretty format");

  parser.parseArgs(args);

  const inputFiles = inputFilesArg.values();
  const outputFile = if outputFileArg.hasValue() then outputFileArg.value() else "";
  const csv = csvArg.valueAsBool();


  var uniqueWarnings  = new map(string, int);

  if inputFiles.size > 0 then
    for inputFile in inputFiles {
      var inputFileReader = IO.openReader(inputFile);
      countUniqueWarnings(uniqueWarnings, inputFileReader);
    }
  else
    countUniqueWarnings(uniqueWarnings, IO.stdin);

  var outputFileWriter = if outputFile != "" then IO.openWriter(outputFile) else IO.stdout;

  if csv then
    csvPrintMap(uniqueWarnings, outputFileWriter);
  else
    prettyPrintMap(uniqueWarnings, outputFileWriter);
}
